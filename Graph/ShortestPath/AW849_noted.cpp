/*
总结起来核心就三步，肥肠煎蛋

首先寻找目前状态下离第一个结点距离最小的结点

然后将这个结点加入已经确定距离的结点中

接着更新状态，即加入新的结点后看看是否因为这个新加的结点而出现一条更短的距离，如果有，就更新距离
*/

#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 510;
int n, m;
int g[N][N];  // g[ 1 ][ 2 ]是指从1节点指向2节点的距离，也可以表示不存在
int dist[N];  // distance（距离）的缩写，代表每一个点到源点的距离
bool st[N];
// state(状态)的缩写,当st[n]为true时说明这个点到源点的距离最小值就已经确定了
int dijkstra() {
    memset(dist, 0x3f, sizeof(dist));  // 存储每一个点到源点的距离
    // 比较大的数
    dist[1] = 0;  // 源点到自己的距离为0
    for (int i = 0; i < n - 1; i++) {
        // 其实这条语句唯一的作用就是循环n-1次（优化了）
        // 所以写成for(int i=0;i<n;i++)也可以，
        // 因为如果下面的语句循环了n-1次的话，那么所有点都能得到最小值了
        // 可以这么理解，每次循环都会确定一个最小值，还会再创造一个最小值（留给下一次循环去确定）
        // 当循环n-1次时，情况是已经确定了n-1个点的最小值了，还创造了一个最小值(此时还有1个点等着下一次去确定)
        // 那么就不需要下一次循环了，毕竟剩下的就一个点，在1个点的集合中知道有一个点是最小值，顺理成章了
        // 当然你想写成for(int i=0;i<n;i++)也能AC~~小声说~~
        int t = -1;
        for (int j = 1; j <= n; j++) {
            if (!st[j] and (t == -1 or dist[t] > dist[j])) {
                t = j;
                //! st[j]指的是最近距离还没有确定的点，and后面就是找符合！st[j]条件的距离最小的点
                // 这一个操作就是找到未确定最小值的
                // `点集`中的最小点,t==-1是当第一次遇到未确定~的点时能够被初始化
            }
        }
        //(1)
        for (int j = 1; j <= n; j++) {
            // 现在找到t了，遍历一遍所有点，有一下几种情况
            // 1.j点和t点之间无连接，那么g[t][j]=0x3f3f3f3f,特别大，会被pass
            // 2.dist[j]<=dist[t]+g[t][j],源点到j点的距离，如果经过t后距离更长了，那么不考虑
            // 3.dist[j]<=dist[t]+g[t][j],，~~，经过t点距离更短了，那么修改dist[j]的值
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        }
        st[t] = true;
        // 当前t点已经把其余点全部遍历了一遍，此点变成确定距离为最小的点了,这条语句放在（1）处也能AC
    }
    if (dist[n] == 0x3f3f3f3f) {
        // 当前点n没被修改，说明到不了点n，输出-1
        return -1;
    } else {
        return dist[n];  // 易证
    }
}
int main() {
    cin >> n >> m;  // n存点数，m存边数
    memset(g, 0x3f, sizeof(g));
    // 将点之间的距离的每一个值设置成很大的数，此知识点之前讲过
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = min(g[a][b], c);  // 有效解决多条边的问题，保留最短边
    }
    cout << dijkstra() << endl;
    return 0;
}
