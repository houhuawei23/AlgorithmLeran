/*
多重背包问题 II
https://www.acwing.com/problem/content/5/

二进制优化方法
0 < N <= 1000
0 < V <= 2000
0 < vi,wi,si <= 2000

原始 DP: O(N*V*K) = 1e(3+3+3) * 2 *2 = 4e9, TLE


*/

/*

输入样例
4 5
1 2 3
2 4 1
3 4 3
4 5 2
输出样例：
10
*/

#include <iostream>
#include <algorithm>

using namespace std;
/*
二进制优化（下方举例说明）：
- 假定物品件数s=200
- 二进制形式 k[n]={1,2,4,8,16,32,64,73} 其所有值相加是<=200
    可以凑出[0~200]的所有数
- 除开最后一个数不是二进制形式，73=200-(1+2+4+8+16+31+64)
- 其余数，若定64，其中64+[0~63]->[0~127]
- 最后一个数73，其中73+[0~127]->[0~200]

这样, 一个可选数量为 si 个的物品 i, 
就被拆成了若干 数量为 1 的, 体积 k*vi, 价值 k*wi 的 的新物品
其中 k in {1,2,4,8,16,32,64,73}, 即 si 的二进制拆分

原问题转换成 01背包问题, 复杂度为: 
O(newN * V) = O(N*log2(S)*V) = 1e3 * log2(2e3) * 2e3 = 2.2e7
*/
// 此处1000 * log2000 , 向上取整数N 得11000
// 二进制优化 s <= 2000, 最多能拆成 log2 s 个数, 则最大 log2 2000
// log2(2000) = 10.97, upper 11
const int N = 11010, M = 2010;

int n, m;  // n表示物品总数，m表示背包容积
int v[N], w[N];  // v[i]表示第i件物品的体积，w[i]表示第i件物品的价值
int f[N];  // 组合方案中的最大价值

int main() {
    cin >> n >> m;
    int cnt = 0;  // 用来存储所有新的物品

    for (int i = 1; i <= n; i++) {
        int a, b, s;
        cin >> a >> b >> s;  // 输入当前物品的体积，价值，个数
        int k = 1;  // 此处二进制优化，从1开始分（假定选择当前物品的总数为k）
        while (k <= s) {
            cnt++;           // 编号增加
            v[cnt] = a * k;  // 体积*物品总数
            w[cnt] = b * k;
            s -= k;  // 从总个数s中减去k个
            k *= 2;  // 二进制，乘以二继续循环
        }
        if (s > 0) {
            // 若总个数s还有剩余
            cnt++;           // 编号增加
            v[cnt] = a * s;  // 体积*剩余个数
            w[cnt] = b * s;
        }
    }

    n = cnt;  // 将n更新为cnt

    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= v[i]; j--) {
            // 此处优化成一维，次数使用倒序，因为原
            // f[i][j] = max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k)
            // 其中v[i]和w[i]已经是选定个数k后更新的体积和价值
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }

    cout << f[m] << endl;

    return 0;
}
