并查集 Disjoint-set
- 每个集合用一棵树来表示, 树根的编号就是整个集合的编号
- 每个结点存储其父结点 `p[x]`
- 判断树根: `p[x] == x`
- 求x的集合编号: 
  - `find(x)`: `while(p[x] != x) x = p[x]; return x;`
- 合并两个集合: `p[find(x)] = find(y)`
- 优化: 路径压缩, O(n) -> O(1)
- 拓展
  - 记录集合大小 size: 绑定到根结点
  - 记录结点到根的距离 d: 绑定到每个元素上
- 应用:
  - 连通性判断: 遍历所有边, 合并连通的点的集合, 统计共有几个集合
  - 最小生成树 Kruskal: 将所有结点分为 "入树" 和 "未入树" 两个集合
  - 最近公共祖先 LCA
- 复杂拓展
  - 可持久化并查集
  - 可撤销并查集